// Draws heavily on the VancOutput example inthe BM Decklink SDK Examples
//
// Blackmagic's license starts here:
/* -LICENSE-START-
 ** Copyright (c) 2014 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

//#include "platform.h"

#include <stdint.h>
#include <DeckLinkAPI.h>

#include "g3log/g3log.hpp"

#include "Identical3DFrames.h"
#include "SDICameraControl.h"

namespace libblackmagic {


// Frame parameters
// const uint32_t kFrameDuration = 1000;
// const uint32_t kTimeScale = 25000;
const uint32_t kFrameWidth = 1920;
const uint32_t kFrameHeight = 1080;
const uint32_t kRowBytes = 5120;

const BMDPixelFormat      kPixelFormat = bmdFormat10BitYUV;


// 10-bit YUV blue pixels
const uint32_t kBlueData[4] = { 0x40aa298, 0x2a8a62a8, 0x298aa040, 0x2a8102a8 };

// Studio Camera control packet:
// Set dynamic range to film.
// See Studio Camera manual for more information on protocol.
//const uint8_t kSDIRemoteControlData[9] = { 0x00, 0x07, 0x00, 0x00, 0x01, 0x07, 0x01, 0x00, 0x00 };

// Data Identifier
const uint8_t kSDIRemoteControlDID = 0x51;

// Secondary Data Identifier
const uint8_t kSDIRemoteControlSDID = 0x53;

// Define VANC line for camera control
const uint32_t kSDIRemoteControlLine = 16;

// Keep track of the number of scheduled frames
//uint32_t gTotalFramesScheduled = 0;


//  This function translates a byte into a 10-bit sample
//   x x x x x x x x x x x x
//       -------------------
//   | | |  0-7 raw data   |
//   | |
//   | even parity bit
//   inverse of bit 8
static inline uint32_t EncodeByte(uint32_t byte)
{
	uint32_t temp = byte;
	// Calculate the even parity bit of bits 0-7 by XOR every individual bits
	temp ^= temp >> 4;
	temp ^= temp >> 2;
	temp ^= temp >> 1;
	// Use lsb as parity bit
	temp &= 1;
	// Put even parity bit on bit 8
	byte |= temp << 8;
	// Bit 9 is inverse of bit 8
	byte |= ((~temp) & 1) << 9;
	return byte;
}

// This function writes 10bit ancillary data to 10bit luma value in YUV 10bit structure
static void WriteAncDataToLuma(uint32_t*& sdiStreamPosition, uint32_t value, uint32_t dataPosition)
{
	switch(dataPosition % 3)
	{
		case 0:
			*sdiStreamPosition++  = (value) << 10;
			break;
		case 1:
			*sdiStreamPosition = (value);
			break;
		case 2:
			*sdiStreamPosition++ |= (value) << 20;
			break;
		default:
			break;
	}
}

static void WriteAncillaryDataPacket(uint32_t* line, const uint8_t did, const uint8_t sdid, const uint8_t* data, uint32_t length)
{
	// Sanity check
	if (length == 0 || length > 255)
		return;

	const uint32_t encodedDID  = EncodeByte(did);
	const uint32_t encodedSDID = EncodeByte(sdid);
	const uint32_t encodedDC   = EncodeByte(length);

	// Start sequence
	*line++ = 0;
	*line++ = 0x3ff003ff;

	// DID
	*line++ = encodedDID << 10;

	// SDID and DC
	*line++ = encodedSDID | (encodedDC << 20);

	// Checksum does not include the start sequence
	uint32_t sum = encodedDID + encodedSDID + encodedDC;
	// Write the payload
	for(uint32_t i = 0; i < length; ++i)
	{
		const uint32_t encoded = EncodeByte(data[i]);
		WriteAncDataToLuma(line, encoded, i);
		sum += encoded & 0x1ff;
	}

	// Checksum % 512 then copy inverse of bit 8 to bit 9
	sum &= 0x1ff;
	sum |= ((~(sum << 1)) & 0x200);
	WriteAncDataToLuma(line, sum, length);
}

static void SetVancData(IDeckLinkVideoFrameAncillary* ancillary, BMSDIBuffer *cmd )
{
	HRESULT   result;
	uint32_t* buffer;

	result = ancillary->GetBufferForVerticalBlankingLine(kSDIRemoteControlLine, (void **)&buffer);
	if (result != S_OK)
	{
		LOGF(WARNING, "Could not get buffer for Vertical blanking line - result = %08x\n", result);
		return;
	}

	// Write camera control data to buffer
	WriteAncillaryDataPacket(buffer, kSDIRemoteControlDID, kSDIRemoteControlSDID,
													(const uint8_t *)cmd->data, cmd->len);
}

static void FillBlue(IDeckLinkMutableVideoFrame* theFrame)
{
	uint32_t* nextWord;
	uint32_t  wordsRemaining;

	theFrame->GetBytes((void**)&nextWord);
	wordsRemaining = (kRowBytes * kFrameHeight) / 4;

	while (wordsRemaining > 0)
	{
		*(nextWord++) = kBlueData[0];
		*(nextWord++) = kBlueData[1];
		*(nextWord++) = kBlueData[2];
		*(nextWord++) = kBlueData[3];
		wordsRemaining = wordsRemaining - 4;
	}
}


//=== Public functions ====

IDeckLinkMutableVideoFrame* makeFrameWithSDIProtocol( IDeckLinkOutput *deckLinkOutput, BMSDIBuffer *buffer, bool do3D )
{
	return addSDIProtocolToFrame( deckLinkOutput, makeBlueFrame( deckLinkOutput, do3D ), buffer );
}


IDeckLinkMutableVideoFrame* addSDIProtocolToFrame( IDeckLinkOutput *deckLinkOutput, IDeckLinkMutableVideoFrame* frame, BMSDIBuffer *buffer )
{
	HRESULT                       result;
	IDeckLinkVideoFrameAncillary*	ancillaryData = nullptr;

	result = deckLinkOutput->CreateAncillaryData(kPixelFormat, &ancillaryData);
	if(result != S_OK)
	{
		LOGF(WARNING, "Could not create Ancillary data - result = %08x\n", result);
		goto bail;
	}

	SetVancData( ancillaryData, buffer );
	result = frame->SetAncillaryData(ancillaryData);
	if (result != S_OK)
	{
		LOGF(WARNING, "Fail to set ancillary data to the frame - result = %08x\n", result);
		goto bail;
	}

bail:

	// Release the Ancillary object
	if(ancillaryData != NULL)
		ancillaryData->Release();

	 return frame;
}



IDeckLinkMutableVideoFrame* makeBlueFrame( IDeckLinkOutput *deckLinkOutput, bool do3D )
{
	HRESULT                         result;
	IDeckLinkMutableVideoFrame*     frame = nullptr;

	result = deckLinkOutput->CreateVideoFrame(kFrameWidth, kFrameHeight, kRowBytes, kPixelFormat, bmdFrameFlagDefault, &frame);
	if (result != S_OK)
	{
		LOGF(WARNING, "Could not create a video frame - result = %08x\n", result);
		goto bail;
	}

	FillBlue(frame);

bail:
  return frame;
}


}

// Original sample code from BMD Example
// int main(int argc, const char * argv[])
// {
//
// 	IDeckLinkIterator*      deckLinkIterator = NULL;
// 	IDeckLink*              deckLink         = NULL;
// 	IDeckLinkOutput*        deckLinkOutput   = NULL;
// 	OutputHandler*         OutputHandler   = NULL;
// 	IDeckLinkVideoFrame*    videoFrameBlue   = NULL;
// 	HRESULT                 result;
//
// 	Initialize();
//
// 	// Create an IDeckLinkIterator object to enumerate all DeckLink cards in the system
// 	result = GetDeckLinkIterator(&deckLinkIterator);
// 	if(result != S_OK)
// 	{
// 		fprintf(stderr, "A DeckLink iterator could not be created.  The DeckLink drivers may not be installed.\n");
// 		goto bail;
// 	}
//
// 	// Obtain the first DeckLink device
// 	result = deckLinkIterator->Next(&deckLink);
// 	if(result != S_OK)
// 	{
// 		fprintf(stderr, "Could not find DeckLink device - result = %08x\n", result);
// 		goto bail;
// 	}
//
// 	// Obtain the output interface for the DeckLink device
// 	result = deckLink->QueryInterface(IID_IDeckLinkOutput, (void**)&deckLinkOutput);
// 	if(result != S_OK)
// 	{
// 		fprintf(stderr, "Could not obtain the IDeckLinkInput interface - result = %08x\n", result);
// 		goto bail;
// 	}
//
// 	// Create an instance of output callback
// 	OutputHandler = new OutputHandler(deckLinkOutput);
// 	if(OutputHandler == NULL)
// 	{
// 		fprintf(stderr, "Could not create output callback object\n");
// 		goto bail;
// 	}
//
// 	// Set the callback object to the DeckLink device's output interface
// 	result = deckLinkOutput->SetScheduledFrameCompletionCallback(OutputHandler);
// 	if(result != S_OK)
// 	{
// 		fprintf(stderr, "Could not set callback - result = %08x\n", result);
// 		goto bail;
// 	}
//
// 	// Enable video output
// 	result = deckLinkOutput->EnableVideoOutput(kDisplayMode, kOutputFlag);
// 	if(result != S_OK)
// 	{
// 		fprintf(stderr, "Could not enable video output - result = %08x\n", result);
// 		goto bail;
// 	}
//
// 	// Create a frame with defined format
// 	videoFrameBlue = CreateFrame(deckLinkOutput);
//
// 	// Schedule a blue frame 3 times
// 	for(int i = 0; i < 3; i++)
// 	{
// 		result = deckLinkOutput->ScheduleVideoFrame(videoFrameBlue, gTotalFramesScheduled*kFrameDuration, kFrameDuration, kTimeScale);
// 		if(result != S_OK)
// 		{
// 			fprintf(stderr, "Could not schedule video frame - result = %08x\n", result);
// 			goto bail;
// 		}
// 		gTotalFramesScheduled ++;
// 	}
//
// 	// Start
// 	result = deckLinkOutput->StartScheduledPlayback(0, kTimeScale, 1.0);
// 	if(result != S_OK)
// 	{
// 		fprintf(stderr, "Could not start - result = %08x\n", result);
// 		goto bail;
// 	}
//
// 	// Wait until user presses Enter
// 	printf("Monitoring... Press <RETURN> to exit\n");
//
// 	getchar();
//
// 	printf("Exiting.\n");
//
// 	// Stop capture
// 	result = deckLinkOutput->StopScheduledPlayback(0, NULL, 0);
//
// 	// Disable the video input interface
// 	result = deckLinkOutput->DisableVideoOutput();
//
// 	// Release resources
// bail:
//
// 	// Release the video input interface
// 	if(deckLinkOutput != NULL)
// 		deckLinkOutput->Release();
//
// 	// Release the Decklink object
// 	if(deckLink != NULL)
// 		deckLink->Release();
//
// 	// Release the DeckLink iterator
// 	if(deckLinkIterator != NULL)
// 		deckLinkIterator->Release();
//
// 	// Release the videoframe object
// 	if(videoFrameBlue != NULL)
// 		videoFrameBlue->Release();
//
// 	// Release the OutputHandler callback object
// 	if(OutputHandler)
// 		delete OutputHandler;
//
// 	return(result == S_OK) ? 0 : 1;
// }
